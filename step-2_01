サンプルコード①

const { test, expect } = require('@playwright/test');

test('Googleで検索して結果を確認する', async ({ page }) => {
  await page.goto('https://www.google.com');
  await page.fill('input[name="q"]', 'Playwright');
  await page.keyboard.press('Enter');
  await page.waitForTimeout(2000);
  await expect(page).toHaveTitle(/Playwright/);
});

* Googleのトップページにアクセスする
* 検索ボックスに「Playwright」と入力
* Enterキーで検索を実行
* 検索結果の表示まで少し待機
* ページタイトルに「Playwright」が含まれていることを確認
テスト観点： 「検索が正しく実行され、結果画面に遷移できているか」

サンプルコード②

const { test, expect } = require('@playwright/test');

test('ログインフォームに入力してログインボタンを押す', async ({ page }) => {
  await page.goto('https://example.com/login');
  await page.fill('#username', 'testuser');
  await page.fill('#password', 'secret123');
  await page.click('button[type="submit"]');
  await expect(page).toHaveURL('https://example.com/dashboard');
});

await page.goto('https://example.com/login');

* 意味：ブラウザで https://example.com/login にアクセスする
* 目的：ログイン画面を表示する
* await を使っていることで「ページの読み込みが完了するまで待つ」

await page.fill('#username', 'testuser');

* 意味：#username という入力欄に testuser という文字を入力する
* セレクタ #username：
　　# は「ID」を意味し、username は入力欄のID名
　　つまり、IDが username というHTML要素を指定している
* fill() は、指定した要素に指定した文字列を入力する関数

await page.click('button[type="submit"]');

submit はHTMLのフォームを送信するためのボタンに使われるボタンタイプの一種です。
* フォームの送信（submit）を意味する
* ログイン画面などでは、ユーザー名とパスワードを入力した後に「ログイン」ボタンを押して情報を送信します。
* 通常、<button type="submit"> と定義されたボタンが、ユーザーが入力した内容（ユーザー名やパスワードなど）をサーバーに送信する役割を持っています。

* submit ボタンは実際のボタンの名前に関係なく、フォームを送信するボタンを指しています。
* ログイン画面では、パスワードを入力する欄がなくても、実際に「ログイン」ボタンは フォーム送信ボタン（submit）として機能しています。

* ログインボタンも、実際には「フォーム送信ボタン（submit）」と呼ばれるタイプのボタンであり、クリックするとユーザーが入力したデータ（例：ユーザー名、パスワード）をサーバーに送信します。
* このサンプルコードでは、パスワードの入力は前のコード行で入力されているので、実際にはこのsubmitボタンを押すことでログイン処理が進みます。

await expect(page).toHaveURL('https://example.com/dashboard');

* 意味：ページのURLが https://example.com/dashboard であることを確認する。
* 目的：ユーザーがログイン後、ダッシュボード画面に遷移したことを確認する
　　　　   - これが成功すれば、「ログインが成功してダッシュボードに遷移した」と判断できる。
* expect() と toHaveURL() は、Playwrightのアサーション（検証）関数で、ページの状態が期待通りであることを確認します。

サンプルコード③

const { test, expect } = require('@playwright/test');

test('商品をカートに追加する', async ({ page }) => {
  await page.goto('https://example.com/shop'); // 商品ページに移動
  await page.click('button[data-testid="add-to-cart"]'); // 商品をカートに追加
  const cartCount = await page.innerText('.cart-count'); // カート内のアイテム数を取得
  await expect(cartCount).toBe('1'); // カートに1つの商品が追加されたことを確認
});

サンプルコード③ 解答まとめ

問い1：操作の順番と内容
1. page.goto('https://example.com/shop') → example.comのショップページにアクセスする操作である。
2. page.click('button[data-testid="add-to-cart"]') → 商品の「カートに追加」ボタンをクリックする。 ※data-testid属性はテスト用に設定された識別子で、対象要素の特定に使われる。
3. const cartCount = await page.innerText('.cart-count') → カート内に表示されている商品数（カウント）を取得する。
4. expect(cartCount).toBe('1') → 取得したカウントが「1」であることを確認し、1件だけ商品が追加されたかを検証する。

問い2：テスト対象
* カート機能の基本動作が対象。
* ユーザーが「カートに追加」ボタンを押したとき、本当に商品がカートに入るか、その結果がカウントとして画面に正しく反映されているかを確認している。

const cartCount = await page.innerText('.cart-count');

コードの意味と動作

page.innerText(selector)
* これはPlaywrightのメソッドで、指定した要素内のテキストを取得する命令です。
* selectorの部分には、CSSセレクタを指定します。
* 取得されるのは、画面上に実際に表示されているテキストです（HTMLタグではなく、ユーザーに見える文字）。

.cart-count について
* この部分は CSSセレクタで、.cart-count という クラス名がついた要素を指定しています。
* つまり、ページ内にある <div class="cart-count">1</div> のような要素から、**「1」**というテキストを取り出してくれるわけです。

結果の保存

const cartCount = ...

* const を使って cartCount という変数に代入しています。
* この変数には、「カートの中に入っている商品の個数」が 文字列として 保存されます。
* 例："1" や "2" といったテキスト。

この行でやっていることのまとめ
* カートのアイコンなどに表示されている「現在の商品の個数（テキスト）」を取得し、それを cartCount という変数に保存している。
* その後のテストコードで、この変数を使って期待値と比較している。

補足：innerTextとtextContentの違い
* innerText は、表示されているテキストのみを対象にし、スタイルの影響（非表示要素など）を受ける。
* textContent は、DOM上に存在するすべてのテキストを対象にするため、非表示のものも含む。
テストでは、通常は innerText を使った方が、ユーザーに見える内容を確認するのに適しているため、このコードでもそうなっています。

とても良い視点です！ 結論から言うと、「1点アイテムを追加する操作の結果を確認している」ので、あなたの理解はほぼ正しいです。 ただし、細かく分けてみると、少しだけニュアンスの違いがあります。

あらためて整理すると：
await page.click('button[data-testid="add-to-cart"]');
→ ここで「1点アイテムを追加する操作」を実行しています。 （= 商品を1つカートに追加する処理）

const cartCount = await page.innerText('.cart-count');
→ ここは「何点追加されたかを画面から取得して確認する」ための処理です。 つまり、
* 「追加した」ではなく
* 「追加された結果として何点になったかを取得している」

結論として
* 追加する操作 → click()
* 追加されたかを確認する操作 → innerText() で表示を取得

なので、「innerText() は 1点追加する操作ではない」という理解は正しいです。 でも、「1点追加したかを確認している」という意味では、あなたの最初の見方も ほぼ合っていた ということになります。

こうした「操作」と「確認」の区別は、自動テストの読解でもすごく大事なので、今の時点で気づけているのは素晴らしいです！
さらに理解を深めたい場合は、「この後の検証処理で何と比較しているのか（例：expect(cartCount).toBe('1')）」もセットで意識すると、さらに精度が上がってきます

サンプルコード④

const { test, expect } = require('@playwright/test');

test('不正なメールアドレスでフォームを送信する', async ({ page }) => {
  await page.goto('https://example.com/contact'); // 問い合わせフォームに移動
  await page.fill('#email', 'invalid-email'); // 不正なメールアドレスを入力
  await page.click('button[type="submit"]'); // 送信ボタンをクリック
  const errorMessage = await page.innerText('.error-message'); // エラーメッセージを取得
  await expect(errorMessage).toBe('無効なメールアドレスです。'); // エラーメッセージが表示されることを確認
});

サンプルコード④：読解まとめ

▼ 問1：操作の順序と内容
1. page.goto('https://example.com/contact') 　→ Example.com の お問い合わせ（Contact）ページを開く。
2. await page.fill('input[name="email"]', 'invalid-email') 　→ email という名前の 入力欄に「invalid-email」（無効な形式のメールアドレス）を入力。 　※ @ やドメインが入っていないので、形式として不正。
3. await page.click('button[type="submit"]') 　→ 送信ボタン（Submit）をクリック。 　※ 多くのフォームでは、<button type="submit">送信</button>のようになっている。
4. const error = await page.innerText('.error-message') 　→ .error-message クラスのついた要素から、表示されている エラーメッセージのテキストを取得。
5. expect(error).toContain('無効なアドレスです。') 　→ 取得したエラーメッセージが、「無効なアドレスです。」という文言を含んでいるかどうかを確認。

▼ 問2：テスト対象の確認
* テスト対象は、「メールアドレスのバリデーション（検証）機能」。
* ユーザーが無効なメールアドレスを入力して送信しようとしたときに、システムが正しくエラーを表示するかどうかを確認している。
* その結果として、「無効なアドレスです。」というメッセージが画面上に表示されていればOK。

補足ポイント
* innerText() と expect(...).toContain(...) のコンボは、「ある文字列が画面に含まれているか」を調べる定番のやり方です。
* toBe() と toContain() の違いも覚えておくと良い：
    * toBe('文字列') → 完全一致
    * toContain('文字列') → 一部一致OK


形式として正しいかどうか（例：invalid-emailが形式的に正しいか）」と「そのメールアドレスがシステムに登録されているか」**は全く別の話です

await page.fill('input[name="email"]', 'invalid-email');

* これは 「形式エラー（例：@がない）」を検知する」 ためのテストです。
* 入力された値が "invalid-email" で、形式として不正な場合、画面上に「無効なアドレスです。」などと表示されます。

登録済みメールアドレスかどうかもチェックしたい場合
これは **「バックエンドとの連携で、存在確認（登録済かどうか）をする」**ような機能になります。
たとえば、登録済みでないアドレスを使って「ログイン」や「パスワード再設定」などをしようとしたときに、以下のようなエラーメッセージが表示されることがあります：
* 「このメールアドレスは登録されていません」
* 「ユーザーが見つかりませんでした」

await page.goto('https://example.com/password-reset');

await page.fill('input[name="email"]', 'notregistered@example.com');
await page.click('button[type="submit"]');

const error = await page.innerText('.error-message');
expect(error).toContain('このメールアドレスは登録されていません');

ポイント
* フォーム自体はメールアドレスの形式をチェックしたうえで、
* サーバーに**実在チェック（登録済かどうか）**のリクエストを送り、
* 存在しない場合にエラーメッセージを返す。

まとめ
チェック内容	必要なテスト対象	Playwrightでの確認方法
形式チェック（@など）	フロントエンドのバリデーション	fill + click + innerText
登録済みチェック	バックエンド連携	同上（ただし内容がサーバー依存）

サンプルコード⑤


const { test, expect } = require('@playwright/test');

test('ログイン後にプロフィールを確認する', async ({ page }) => {
  await page.goto('https://example.com/login');
  await page.fill('#username', 'testuser');
  await page.fill('#password', 'securepass');
  await page.click('button[type="submit"]');
  await page.waitForSelector('.profile');
  const username = await page.innerText('.profile .username');
  expect(username).toBe('testuser');
});

問1：このテストコードで行われている操作の流れ（日本語での説明）
1. https://example.com/login にアクセスし、ログイン画面を表示する
2. #username のテキストボックスに「testuser」と入力する
3. #password のテキストボックスに「securepass」と入力する
4. button[type="submit"]（ログインボタン）をクリックする
5. .profile というクラスを持つ要素が画面に現れるまで待つ（プロフィール画面が表示されたことを確認）
6. .profile .username 要素に表示されているテキスト（ユーザー名）を取得する
7. 取得したユーザー名が「testuser」であることを確認する

問1（6と7の詳細）
６．該当画面にプロフィールとユーザーネームが表示されていることを確認する

await page.waitForSelector('.profile');

.profileというCSSセレクタ（クラス）を持つ要素が出現するまで待つ。
これはつまり、「プロフィール情報が表示された画面が現れたこと」を意味する。
→ 画面が切り替わって、ログイン後のプロフィール画面になったことを確認している操作。

７．ユーザーネームが「testuser」であることを確認する

const username = await page.innerText('.profile .username');
expect(username).toBe('testuser');

* .profile .username というセレクタにあるテキスト要素を取得して username という変数に代入。
* その値が 'testuser' と一致するかをチェックしている。
* これは、ログイン後に表示されるユーザー情報が 正しいユーザーのもの（testuser）かどうか を検証する操作。

問2：テスト対象の観点
観点は以下の通りです：
「ログイン後に、正しいユーザー情報が画面上に表示されるかどうか」
もう少し具体的に書くと：
* 正常なユーザー名とパスワードでログインできるか
* ログイン後に、想定されたユーザー情報（ユーザー名）が画面に表示されるか
これらが E2E（エンド・ツー・エンド）テストとしての典型的な観点です。
