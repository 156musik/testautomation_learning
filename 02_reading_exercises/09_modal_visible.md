# 09：モーダルの出現待ち

## テストコード

```js
test('要素が表示されるまで待つ', async ({ page }) => {
  await page.goto('https://example.com/loading');
  await page.click('#startLoad');
  await expect(page.locator('#loadedContent')).toBeVisible();
});
```

### 問題

問１　上記のテストコードが行っている操作の流れを、日本語で説明してください。

問２　このテストコードで確認している観点（チェックポイント）は何でしょうか？

### 自分の回答

問１
1. Example.comのローディング画面に遷移する
2. 「ローディングを開始する」を押下する
3. ．ページの読み込みが完了したことを確認する

問２

ローディングができることの確認

### 回答/解説

問１
1. Example.comのローディング画面に遷移する
   - 正しいです。

2. 「ローディングを開始する」を押下する
   - #startLoad ボタンをクリックしているので、ボタンのラベルが実際に「ローディングを開始する」であるなら正しいです。ラベルがそうでない場合は「ローディング開始ボタンを押下する」などにしておくのが安全です。

3. ページの読み込みが完了したことを確認する
   - 少しあいまいな表現です。このコードが確認しているのは「ページ全体の読み込み完了」ではなく、「非表示だった要素 #loadedContent が表示されるようになった」ことです。

よって、より正確な説明としては次のようになります：

> 3. 非表示だった要素 #loadedContent が表示されるまで待つ

問２
- ローディングができることの確認
   - こちらも少し曖昧です。このコードの観点は「ローディングの開始操作を行った後、指定の要素が正しく表示されること」です。

より明確な表現例：

> ローディング操作の完了後に、指定された要素が表示されることの確認


## 追加テストコード

「ローディングスピナーが消えることを待つ」パターンについて追加で出題してもらった

```js
test('スピナーの非表示を待つ', async ({ page }) => {
  await page.goto('https://example.com/spinner');
  await page.click('#startLoading');
  await expect(page.locator('#loadingSpinner')).toBeHidden();
  await expect(page.locator('#resultContent')).toBeVisible();
});

```

### 問題

問１　上記のテストコードが行っている操作の流れを、日本語で説明してください。

問２　このテストコードで確認している観点（チェックポイント）は何でしょうか？

### 自分の回答

問１
1. Example.comのスピナー画面を表示させる
2. StartLoding(画面のボタン名によって変わる認識)を押下する
3. ローディングスピナーが非表示になり画面の読み込みが完了したことを確認する
4. 更新後の画面が表示されたことを確認する

問２

ローディングスピナーが完了後に更新後の画面が表示されたことの確認

### 回答/解説

問１
1. page.goto('https://example.com/spinner')
   - 該当ページ（スピナー付きの画面）にアクセスする。
2. page.click('#startLoading')
   - 「読み込み開始」ボタンを押す。#startLoadingはIDセレクタでボタンを指定。
3. await page.locator('#loadingSpinner').waitFor({ state: 'hidden' });
   - スピナーが非表示（hidden）になるまで待機。＝読み込み終了の合図。
4. await expect(page.locator('#loadedContent')).toBeVisible();
   - 新しい画面の内容（例：読み込み後のメッセージ）が表示されていることを確認。
  
問２
- ローディング中に一時的に表示されるスピナーが正しく消えたか
- その後、読み込み完了後の画面（要素）が確実に表示されたか

という 2段階の確認を行うテストであり、非同期処理や画面遷移に関する確認の重要なパターンのひとつである。

### 追加質問

普通なら何らかの画面にある更新ボタンなどを押下してからLoding画面に遷移する形かと思うが、「await page.goto('https://example.com/spinner');」　のコードの前に更新ボタンなどが表示されている画面に遷移したことを確認するコードなどが入るのではと思った

実際のところはどうか

### 追加質問の解説

通常の流れ（実務に近いケース）

1. ホーム画面や一覧画面などに遷移
   - 例：await page.goto('https://example.com/dashboard');
2. 画面上の「更新」や「詳細を見る」などのボタンを押下
   - 例：await page.click('#updateButton');
3. （※ここでAjax読み込みや画面遷移が発生）
4. スピナーのある画面（読み込み中ページ）に遷移 or 表示
   - 例：await expect(page.locator('#loadingSpinner')).toBeVisible();
5. スピナーが消えるのを待つ → 新しいコンテンツが表示されることを確認

なぜ今回のサンプルでは page.goto('https://example.com/spinner') で始まるのか？

これは Playwrightのサンプルコードが「ピンポイントで確認したい動作」に集中しているから。

つまり「スピナーの表示〜非表示の挙動だけを検証したい」ので、前後の画面遷移は省略されている。

実際のE2Eテストでの推奨構成（例）

```js
// 1. ダッシュボードにアクセス
await page.goto('https://example.com/dashboard');

// 2. 「更新する」ボタンを押下
await page.click('#updateBtn');

// 3. スピナーが表示されるのを確認
await expect(page.locator('#loadingSpinner')).toBeVisible();

// 4. スピナーが非表示になるまで待機
await page.locator('#loadingSpinner').waitFor({ state: 'hidden' });

// 5. 更新後のコンテンツが表示されたことを確認
await expect(page.locator('#updatedData')).toBeVisible();
```

結論
- page.goto() は単に「スピナー画面に直接アクセスする簡易テスト用」
- 実務では、前段の画面＋遷移操作＋待機処理を含めるのが基本
- そのため、指摘の通り「事前に表示されている画面の確認」が本来のテスト設計では必要になる

Ajaxとして成り立つ条件（今回該当するポイント）

| 条件                  | 内容                | 今回のケースとの関係                     |
| ------------------- | ----------------- | ------------------------------ |
| ① ブラウザとサーバ間で非同期通信する | ページ全体の再読み込みなしで通信  | ✔ スピナー中に裏で通信が発生していると想定される      |
| ② データ取得・更新が行われる     | 例：商品一覧取得、在庫情報更新など | ✔ ローディング完了後に「新しい内容」が画面に表示される   |
| ③ ユーザー操作に応じて通信が始まる  | ボタンやリンククリックで通信開始  | ✔ 「StartLoading」ボタン押下で通信開始している |
| ④ DOMの一部を書き換える      | 全画面リロードなしで表示が変化   | ✔ スピナーが消え、新しい要素が表示される          |

Ajaxでないケースとの違い
- 画面全体がリロードされる（F5で更新するようなもの） → これはAjaxではない
- 遷移先のURLが完全に別になる（画面遷移） → SPA（Single Page Application）やAjaxの使い方による

結論

このようなスピナー付きの非同期UI挙動は、Ajaxを使った処理であると見なせる。

